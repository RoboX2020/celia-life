MedVault Demo – Full-Stack Spec (Frontend + Backend)

GOAL
Build a demo web app (“MedVault Demo”) that lets a patient upload any medical-related file (PDFs, images, etc.), stores the original files safely, and shows them organized by type (lab reports, medical images, doctor notes, prescriptions, other). The AI/LLM part will be added later; for now, document type and summaries are generated by simple placeholder logic on the backend.

==================================================
1. FRONTEND SPEC
==================================================

1.1 High-level behavior
- Main screen is a “vault” dashboard.
- User can upload one or multiple files of different types (PDF, images, text docs).
- After upload, each file appears in a list and is tagged with a document type.
- User can filter documents by type (lab reports, medical images, doctor notes, prescriptions, other).
- User can open a document detail view and download/open the original file.

1.2 Supported input types (for uploads)
The upload component must accept at least:
- Documents:
  - PDF: application/pdf
  - Plain text / rich text: .txt, .rtf
  - Word documents: .doc, .docx
- Images of documents (photos, scans):
  - JPEG/JPG: image/jpeg
  - PNG: image/png
  - (Optional later) HEIC/HEIF: common iPhone format
- Medical photos / screenshots:
  - Same image formats as above (photos of lab printouts, prescriptions, imaging reports, portal screenshots).

If a file type is not in the supported list, show an error message and do not upload it.

1.3 Main “Vault” page layout
- Top navigation bar:
  - Left: App name “MedVault Demo”.
  - Right: Placeholder user label, e.g., “Demo patient: Jane Doe”.
- Page split into:
  - Left sidebar (or horizontal tabs) with document type filters.
  - Main content area with:
    - Upload panel at the top.
    - Document list below.

1.4 Upload panel (top of main content area)
- Large drag-and-drop zone plus a “Select files” button.
- Text examples:
  - Title: “Upload your medical files”
  - Subtitle: “Drop PDFs, images, lab results, prescriptions, and doctor notes here.”
- Behavior:
  - Support multiple file uploads in one action.
  - For each selected file:
    - Show an inline status (“Uploading…”, then “Processing…”, then “Ready”).
    - Send a multipart/form-data POST request to the backend: POST /api/documents.
  - On success:
    - Show a toast/notification: “File uploaded and stored”.
    - Add the returned document to the document list without full page reload.
  - On error:
    - Show an error message next to the file and/or toast.

1.5 Document type filters (sidebar or tabs)
Types:
- All documents
- Lab reports
- Medical images
- Doctor notes
- Prescriptions
- Other

Behavior:
- When the user clicks a filter, the frontend either:
  - Calls GET /api/documents?documentType=... to fetch only those, OR
  - Filters the already-loaded documents client-side (implementation choice).
- “All documents” shows all documents sorted by createdAt (newest first).

1.6 Document list (cards or table)
For each document show:
- Title (from backend; fallback = originalFileName).
- Document type badge, with label (Lab report, Medical image, etc.).
- Date of service (if provided) or upload date.
- Source (if provided; otherwise show “Unknown” or hide).
- Actions:
  - “View details” button → navigates to detail view.
  - “Download” icon/button → triggers download endpoint.

Empty state:
- If there are no documents for the current filter:
  - Show simple empty state: icon + “No documents in this category yet. Upload files above to get started.”

1.7 Document detail view
Route example: /documents/[id]

When user clicks “View details”:
- Fetch details from GET /api/documents/:id.
- Show:
  - Title (large).
  - Document type badge.
  - Metadata section:
    - Original file name
    - Document type
    - Date of service (if any)
    - Source (if any)
    - File size
    - Uploaded at (createdAt)
  - “Summary” section:
    - Display shortSummary field from backend (this is a placeholder now; real AI summary later).
  - “Original file” section:
    - Button: “Open / Download original” that calls GET /api/documents/:id/download.

Design:
- Clean, minimal, “medical” feel (white background, subtle grey, rounded cards).
- Responsive layout so that it works on desktop and is at least usable on mobile.

==================================================
2. BACKEND SPEC
==================================================

2.1 Backend responsibilities
The backend is responsible for:
- Accepting file uploads from the frontend.
- Validating and securely storing the original file (never modifying or losing it).
- Creating and maintaining a Document record in a database for each uploaded file.
- Running a simple processing step that:
  - Derives basic metadata (size, mimeType).
  - Assigns a documentType (lab_report, medical_image, doctor_note, prescription, other) using rule-based logic for now.
  - Generates a user-friendly title and a placeholder shortSummary.
- Providing API endpoints to:
  - Upload new documents.
  - List documents (optionally filtered by type).
  - Fetch details for one document.
  - Download/open the original file.

The AI/LLM component (OCR, real classification, real summarization) will later replace the rule-based logic, but the API shapes should remain the same.

2.2 Technology assumptions (flexible)
- Runtime: Node.js with TypeScript.
- Framework: Next.js API Routes, Express, or similar (any full-stack JS framework is fine).
- Database: SQLite or Postgres (via an ORM like Prisma) for the demo.
- File storage: local filesystem directory (e.g., /uploads). Later this can be moved to S3 or cloud storage.

The spec is framework-agnostic; focus on the data model and APIs.

2.3 Data model

2.3.1 Patient (demo-level)
Even if we assume a single demo patient, define a Patient model so it’s easy to support multiple users later.

Fields:
- id: string or integer (primary key)
- name: string
- email: string (optional)
- createdAt: datetime
- updatedAt: datetime

For the demo, you can hardcode a patient with id = 1 and attach all documents to that patient.

2.3.2 Document
Each uploaded file corresponds to one Document record.

Fields:
- id: string or integer (primary key)
- patientId: foreign key → Patient.id
- originalFileName: string (original name from upload)
- storedFilePath: string (path or URL to where the file is saved, e.g. “/uploads/abc123.pdf”)
- mimeType: string (e.g., “application/pdf”, “image/jpeg”)
- sizeBytes: number (file size in bytes)
- documentType: enum/string
  - Allowed values:
    - “lab_report”
    - “medical_image”
    - “doctor_note”
    - “prescription”
    - “other”
- title: string (human-readable; could be generated like “Lab Report (uploaded 2025-11-09)”)
- source: string (clinic/hospital name or patient-specified source; optional)
- dateOfService: date or string (when the medical service occurred; optional in v0)
- shortSummary: string (1–3 sentences; placeholder text for now)
- createdAt: datetime (timestamp for upload)
- updatedAt: datetime

Later we can extend the model with fields such as:
- language
- rawText (OCR/parsed text)
- links to structured entities (problems, medications, lab results, etc.).

2.4 File upload and processing flow

Step-by-step:

1) Frontend → Backend:
- Frontend sends a POST request to /api/documents with Content-Type: multipart/form-data.
- Form fields:
  - file: the uploaded file (required).
  - (Optional later) source, dateOfService, notes.

2) Backend validation:
- Check that “file” exists.
- Check size limit (e.g., max 20 MB).
- Verify that mimeType is in the allowed list (PDF, images, docs).

3) Store original file:
- Generate a unique internal filename (e.g., UUID + original extension).
- Save the file to a storage directory (e.g., ./uploads/<generatedName>).
- Do not modify or compress the original; just store it as-is.

4) Processing function (rule-based for now):
- Call a function, e.g., processUploadedFile(meta), that returns:
  - documentType
  - title
  - shortSummary
  - (optional) dateOfService guess

Input to processUploadedFile:
- originalFileName
- mimeType
- sizeBytes
- (optional) storedFilePath

Example rule-based logic:
- If mimeType starts with “image/” and filename contains any of:
  - “scan”, “mri”, “ct”, “xray” → documentType = “medical_image”.
- Else if filename contains “lab” or “result” → documentType = “lab_report”.
- Else if filename contains “rx” or “prescription” → documentType = “prescription”.
- Else if filename contains “note”, “visit”, or “consult” → documentType = “doctor_note”.
- Else → documentType = “other”.

Title generation example:
- If documentType = “lab_report” → “Lab Report (uploaded YYYY-MM-DD)”.
- If documentType = “medical_image” → “Imaging/Scan (uploaded YYYY-MM-DD)”.
- Else → “Document (uploaded YYYY-MM-DD)”.

shortSummary example (placeholder):
- Always “This is a placeholder summary for demo purposes. In the full version, AI will generate a real summary of the document content.”

dateOfService:
- For now, can be null or guessed from filename if there is a date pattern (optional).

5) Create Document record:
- Insert into the Document table with:
  - patientId (e.g., 1 for demo)
  - originalFileName
  - storedFilePath
  - mimeType
  - sizeBytes
  - documentType (from processing)
  - title
  - source (if provided)
  - dateOfService (if guessed/provided)
  - shortSummary
  - createdAt, updatedAt

6) Response to frontend:
- Return the newly created Document object as JSON.
- Frontend then updates the UI with this object.

2.5 API endpoints

2.5.1 POST /api/documents
Purpose:
- Upload a new document and create a Document record.

Request:
- Content-Type: multipart/form-data
- Fields:
  - file: required
  - source: optional (string)
  - dateOfService: optional (string or ISO date)

Behavior:
- Validate file.
- Store file under /uploads.
- Run processUploadedFile to determine documentType, title, shortSummary.
- Create Document record in DB.
- Return Document JSON.

Response example:
{
  "id": 42,
  "patientId": 1,
  "originalFileName": "LabResults_May2025.pdf",
  "storedFilePath": "/uploads/abc123.pdf",
  "mimeType": "application/pdf",
  "sizeBytes": 234567,
  "documentType": "lab_report",
  "title": "Lab Report (uploaded 2025-11-09)",
  "source": "Unknown",
  "dateOfService": "2025-05-03",
  "shortSummary": "This is a placeholder summary for demo purposes.",
  "createdAt": "2025-11-09T12:34:56.000Z",
  "updatedAt": "2025-11-09T12:34:56.000Z"
}

2.5.2 GET /api/documents
Purpose:
- List all documents for the (demo) patient.

Query parameters:
- documentType: optional string; if provided, only return docs of that type.

Behavior:
- Query the Document table (filtered by documentType if provided).
- Sort results by createdAt DESC.

Response:
- JSON array of Document objects (can omit storedFilePath if you prefer to keep storage internal).

2.5.3 GET /api/documents/:id
Purpose:
- Get full metadata for a single document.

Behavior:
- Look up Document by id.
- Return Document object as JSON.
- If not found, return 404.

2.5.4 GET /api/documents/:id/download
Purpose:
- Allow frontend to open or download the original file.

Behavior:
- Look up Document by id.
- Locate the file at storedFilePath.
- Stream file bytes back with appropriate Content-Type and Content-Disposition headers.

2.5.5 DELETE /api/documents/:id (optional)
Purpose:
- Allow user to delete a document.

Behavior:
- Look up Document by id.
- Delete DB record.
- Delete file from storage.
- Return success status.

2.6 Security and future-proofing (even for demo)
- Never expose raw filesystem paths directly to the client; always go through the download endpoint.
- Validate uploads strictly by type and size; return clear error messages.
- Avoid logging sensitive content; only log minimal metadata (file name, size, mimeType, errors).
- Design processUploadedFile as a clear extension point for future AI:
  - Later it will run OCR on PDFs/images and call an LLM to extract real clinical information.
  - The existing Document model and APIs should continue working with minimal changes.

END OF SPEC
